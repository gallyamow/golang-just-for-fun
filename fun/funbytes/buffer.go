package funbytes

// Buffer предназначен для эффективной работы с буферами байт.
//
// Для чего:
// 1) Не нужно вручную выделять или увеличивать массив — буфер сам растёт по мере необходимости.
// 2) Очень быстрый: минимизирует копирование памяти.
// 3) Удобен для сборки строк или двоичных данных. Часто используется при генерации данных в памяти (например,
// JSON, HTTP-запросы, логирование и т.п.).
//
// Как с ним работать:
// 1) Ненулевой не стоит копировать. У него нет _noCopy - потому что нулевой все же можно копировать. Копировать
// его нельзя, потому что внутри срез байтов. Копии будут указывать на тот же underlying array и смещения off у них разные.
// Копировать надо копируя срез байт в новый buffer.
//
// Как реализован:
// Внутри buf []byte, off - offset чтения, lastRead - тип последней операции (используется для правильного чтения rune)
// Буфером по сути является место с off до len(buf) = m.
// При операции чтения:
// 1) читает с off до заполнения data, либо пока есть данные. Если данных вообще нет - EOF.
// 2) ничего не делает с прочитанными данными
// При записи: добавляет в конец среза.
// Может оказаться что не хватает места, тогда:
// m = len(b.buf) - b.off
// 1) если свободный размер буфера 0 - то есть новых данных нет, а off не 0 - то есть уже читали и сместили - значит
// буфер можно переиспользовать, поэтому обнуляет off и заново будет читать с начала среза.
// 2) если capacity среза позволяет увеличить len до n - делает
// 3) если буфер nil и пишут немного (n < smallBufferSize = 64), то делает аллокацию размером smallBufferSize элемента.
// Тут расчет на то что чтобы не выделять много места сразу
// 4) так как при чтении мы просто перемещаем off, то позади него скапливается уже прочитанное, значит мы можем просто
// занулить off и скопировать данные в начало slice
// 5) крайний вариант делает 2x (исторически так сложилось, в будущем будут реагировать на темп роста), специально
// делает его так append([]byte(nil), make([]byte, c)...) - добавляет данные к новому nil-slice,
// вместо append(b, make([]byte, n)...) текущий. Пишут чтобы не "убегала в кучу".
// При этому получается что с начала массива будут нули, поэтому приходится копировать содержимое туда.
//
// Моя реализация реализует только часть методов, например нет поддержки rune (нет lastRead), truncate, string.
type Buffer struct {
	buf    []byte
	offset int
}

// Bytes возвращает срез байт длиной b.Len() хранящийся в непрочитанной части буфера.
func (b *Buffer) Bytes() []byte {
	return b.buf[b.offset:]
}

// Len возвращает количество байт в непрочитанной части буфера.
func (b *Buffer) Len() int {
	return len(b.buf) - b.offset
}

// Cap возвращает емкость underlying среза, что является, количеством выделенной памяти.
func (b *Buffer) Cap() int {
	return cap(b.buf)
}

// Available возвращает сколько байт не использованы в буфере.
func (b *Buffer) Available() int {
	return cap(b.buf) - len(b.buf)
}

// AvailableBuffer возвращает пустой срез байт емкостью b.Available(), то есть количеству байт, которое можно записать
// без перераспределения памяти.
// Этот срез предназначен последующей записи через buffer.Write().
// Этот срез валиден только до следующей записи в b.
// Смысл: если есть буфер с достаточной ёмкостью, можно напрямую писать в его срез и потом "сообщить" буферу, что данные добавлены.
func (b *Buffer) AvailableBuffer() []byte {
	return b.buf[len(b.buf):]
}

// Reset сбрасывает буфер, сохраняет underlying хранилище для последующих записей.
func (b *Buffer) Reset() {
	b.offset = 0
	b.buf = b.buf[:0]
}

// Write пишет данные из p в буфер, увеличивая его если необходимо.
// Возвращаемое значение n равно длине p, err всегда nil.
// Вызов всегда успешный за исключением превышения размера буфера (maxInt), в там случае паникует с [ErrTooLarge].
func (b *Buffer) Write(p []byte) (n int, err error) {

}

// Read reads the next len(p) bytes from the buffer or until the buffer
// is drained. The return value n is the number of bytes read. If the
// buffer has no data to return, err is [io.EOF] (unless len(p) is zero);
// otherwise it is nil.
func (b *Buffer) Read(p []byte) (n int, err error) {}
