package funccall

import (
	"sync"
	"time"
)

// Debounced возвращает функцию вызов которой выполняет функцию f только после того, как с момента последнего события прошло d-время задержки.
// Таким образом ждет, пока события перестанут происходить в течение заданного времени, и только тогда вызывает функцию.
// Пример: отправка запросов autocomplete поля, гда запрос идет после того как остановился печатать и прошло время.
// Debounced вызов может быть 2 вариантах:
// - Leading Edge - первый вызов выполняется сразу
// - Trailing Edge - первый вызов выполняется после тишины,
//
// Требования:
//   - первый вызов не должен быть успешным сразу (Trailing Edge)
//   - множественные вызовы в пределах delay: откладывается первый
//   - работа в concurrent-среде
//
// @idiomatic calling defer mu.Unlock() для защиты всей функции
func Debounced(f func(), delay time.Duration) func() {
	// Этот mutex и timer получается общий для всех goroutines использующих один returned-функцию.
	var mu sync.Mutex
	var timer *time.Timer // nillable потому что надо отличать первое использование

	return func() {
		// Mutex на всю функцию.
		mu.Lock()
		defer mu.Unlock()

		// Не первый раз nil
		if timer != nil {
			// отменяем запланированное выполнение функции
			timer.Stop()
		}

		// Используя таймер откладываем вызов функции f на время delay. Запуск функции f будет осуществляться в goroutine.
		// Получаем экземпляр timer, через вызов Stop которого можно отменить выполнение.
		// Здесь при использовании любого решения нужно что-то вроде timer, потому что нужно именно отложить вызов на определенное время.
		// Мы здесь не можем просто ждать следующего вызова, как в случае с throttle.
		timer = time.AfterFunc(delay, f)

		// Можно повторно использовать timer через Reset, но у него есть свои тонкости:
		// 1) Reset должен вызываться только на таймере, который остановлен и не имеет ожидающего срабатывания.
		// 2) Проблемы с гонками (data race)
		//if timer == nil {
		//	timer = time.AfterFunc(delay, f)
		//} else {
		//	timer.Reset(delay)
		//}

		// Также можно обойтись без time.AfterFunc, через timer.NewTimer().
		// Другой способ без timer вообще, используя запуск goroutine и sleep в ней.
	}
}
