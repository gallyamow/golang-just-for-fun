package throttler

import (
	"context"
	"time"
)

// TickerThrottler2 - работает на основе ticker.
// TODO: ломает порядок?? не выдерживает интервал
// @idiomatic defer ordering
func TickerThrottler2[T any](ctx context.Context, inputCh <-chan T, limit time.Duration) <-chan T {
	outputCh := make(chan T)

	// Выдает в канал ticker.C данные раз в limit времени.
	// При его остановке тикер не закрывает канал, чтобы не давать ожидающим частые тики (zero-values).
	// Таким образом если в одной goroutine чтение с канала остановленного ticker - то чтение блокируется.
	// (внутренняя реализация не на golang)
	//
	// Часто говорят что он может накапливать тики, но это не совсем так. Внутри у него буферизированный канал размером 1,
	// каждый новый тик отбрасывается если буфер уже заполнен.
	// Дело в том что если gorutine долго не читает из ticker.C, и потом начинает читать, она может получить тик сразу — потому что буфер уже содержит одно «накопленное» значение.
	ticker := time.NewTicker(limit)

	// Эта переменная используется для временного хранения запланированного на отправку значения. Специально используется
	// указатель чтобы можно было сравнивать отсутствием значения (т.е. nil) и иметь возможность занулять после отправки.
	var buffer *T

	go func() {
		// Порядок важен: Будет выполняться с последнего до первого (так как стек LIFO).
		// Здесь:
		// - Сначала закрываем канал, чтобы сигнализировать, что больше данных не будет.
		// - Потом останавливаем тикер, чтобы освободить ресурсы после этого.
		// Неправильный порядок может приводить к send on closed channel: может успеть послать тик, даже после
		// ticker.Stop(), если событие уже было в очереди (Go не гарантирует немедленную остановку).
		defer ticker.Stop()
		defer close(outputCh)

		// Вычитываем все значения и пишем их output, но перед этим ждем ticker.
		// Вместо ticker можно и sleep(limit).
		// У sleep накапливается сдвиг, так как в него попадает время обработки других инструкций.
		for {
			select {
			case <-ctx.Done():
				return
			case val, ok := <-inputCh:
				if !ok {
					return
				}

				// Может терять значения, если и inputCh и ticker сигналят и 2 раза выберется inputCh.
				// Поэтому сначала отправляем уже накопленное.
				// TODO: но теперь может 2 раза отправить без соблюдения интервала
				if buffer != nil {
					// Запись осуществляем также с проверкой контекста.
					select {
					case <-ctx.Done():
						return
					case outputCh <- *buffer:
						buffer = nil
					}
				}

				buffer = &val
			// Специально вынесли сюда, чтобы было реагирование на отмену через контекст при ожидании тика и отсутствии данных в input.
			// Но есть проблема:
			//  - Если сразу будут данные в ticker и в input, то будет осуществлен random выбор. Таким образом может
			//    сработать отправка 2 раза подряд.
			// Решение будет записывать val в переменную и отправлять его после тика.
			case <-ticker.C:
				if buffer != nil {
					// Запись осуществляем также с проверкой контекста.
					select {
					case <-ctx.Done():
						return
					case outputCh <- *buffer:
						buffer = nil
					}
				}
			}
		}
	}()

	return outputCh
}
