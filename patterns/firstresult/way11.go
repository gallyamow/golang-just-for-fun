package firstresult

import (
	"context"
)

// Way11 solves problem 1
// - С buffered 1-size каналом (экономит память и готов к тому что кол-во goroutines большое)
// @idiomatic: запись 1 значения
func Way11(ctx context.Context, addresses []string, key string, getter ResolvedGetter) (string, error) {
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	res := make(chan string, 1)

	for _, addr := range addresses {
		go func(addr string) {
			// Перед долгой работой проверяем отмену. Можно проверить и после работы.
			if ctx.Err() != nil {
				return
			}

			// Здесь оторванный от жизни кейс, где ошибка игнорируется.
			val := getter(ctx, addr, key)

			// Если ни один кейс не готов - select ждёт, пока один из кейсов станет готовым.
			// У нас нет блокирующих действий в case-handler, поэтому опрос будет идти раз за разом.
			select {
			// Если контекст уже отменён, этот кейс сработает сразу.
			// Если не отменён, этот кейс не готов → Go смотрит другие кейсы (res <- val).
			case <-ctx.Done():
			// Если в канале есть свободное место, запись выполняется сразу → не блокирует.
			// Если канал полон, запись не выполнится сразу, и Go ищет другой готовый кейс.
			//
			// В варианте 1) можно было бы и не проверять, так как в буфере достаточно места.
			// В данном случае проверка нужна, чтобы все остальные goroutine пишущие ответ позже первой не блокировались на записи.
			case res <- val:
			// Если канал полон и контекст не отменён → запись пропускается - неблокирующая запись.
			// Текущее решение сработало бы и без этого (потому что ВЕСЬ select будет ждать + case-handler у нас нет блокирующей операции)
			default:
			}
		}(addr)
	}

	// Благодаря defer cancel() все недошедшие до res <- val goroutines будут завершены (либо перейдут в запись,
	// так как switch case - при готовности нескольких выбирает случайный.)
	// А те goroutines те которые дошли публикации результата - не смогут это сделать, но и незаблокируются потому что есть default.
	first := <-res

	// Закрывать канал не можем, потому что кто-то может писать.
	// Никогда не закрываем канал, в который пишут несколько goroutines, если есть риск, что кто-то ещё будет писать.

	// Можем сразу выходить.
	return first, nil
}
