package synccond

import (
	"sync"
	"testing"
)

// TestUsingSyncCond показывает пример как используется sync.Cond.
// Она позволяет одной или нескольким goroutines ждать наступления некоторого события, пока другая goroutine не сообщит
// о том, что событие произошло.
// Cond всегда работает вместе с mutex (sync.Mutex или sync.RWMutex), который защищает общий ресурс.
//
// Для чего он:
// Когда недостаточно защищать критическую область, а нужно в ней ждать наступления какого-то условия. Без него придется
// проверять это условие в цикле в spin нагружая CPU.
//
// Как с ним работать:
// Wait() - Ожидает сигнала. Goroutine приостанавливается, пока не получит Signal() или Broadcast(). Нужно вызывать
// только под захваченным mutex, иначе будет panic.
// Перед ожиданием автоматически отпускает мьютекс и снова блокирует его после пробуждения.
// Signal() - Пробуждает одну goroutine, ожидающую в Wait(). Не обязательно вызывать под mutex, но обычно так делают.
// Broadcast() - Пробуждает все goroutines, ожидающие в Wait(). Не обязательно вызывать под mutex, но обычно так делают.
// Условие проверяют в цикле:
// c.L.Lock() // некоторые используют mutex через cond
//
//	for !condition() {
//	    c.Wait()
//	}
//	... make use of condition ...
//	c.L.Unlock()
//
// Как реализован:
// Wait():
// 1) goroutine регистрируется в notifyList (внутренний список ожидания).
// 2) Отпускает мьютекс L.
// 3) Засыпает (при помощи низкоуровневых примитивов в runtime Go — runtime.notifyListWait).
// 4) Когда кто-то вызывает Signal или Broadcast, runtime пробуждает соответствующие goroutines.
// 5) После пробуждения goroutine автоматически снова захватывает мьютекс.
// Signal()
// Пробуждает одну goroutine из списка notifyList.
// Broadcast()
// Пробуждает все ожидающие goroutines.
//
// После пробуждения goroutine автоматически снова захватывает мьютекс.
func TestUsingSyncCond(t *testing.T) {
	t.Run("basic", func(t *testing.T) {
		var mu sync.Mutex
		cond := sync.NewCond(&mu)
		data := 0

		// Потребитель ждёт, пока появятся данные
		go func() {
			mu.Lock()
			for data == 0 {
				cond.Wait()
			}
			mu.Unlock()
		}()

		// Производитель добавляет данные и сигналит
		mu.Lock()
		data = 42
		cond.Signal()
		mu.Unlock()
	})
}
